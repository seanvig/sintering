---
title: "Optimization of Alumina Kinetics"
author: Sean Taylor and Dennis Taylor
output: html_notebook
---

## Subroutine to evaluate ET(I)

```{r}
library(sintering)
library(dplyr)

data <- alumina %>% filter(Sample == "65")

YY <- function(B,AA) (1-B)/AA
S <- seq(.25,2,by=.25) #Letting the exponent n float
Y <- data$y
T <- data$t
I <- seq(nrow(data))
L <- length(I)

G <- 1e8
MM <- L-2
N<-1:8

i <- 3 ## temporary fix I
n<-1 ## temporary fix for N

for (N in N){
  for (I in c(3:MM)) {
    #call eval
  }
}

R<-i # temporary fix I
R1 = L-i+1

#if (Y[1] -0 < 0.01) drop Y[1]?

##Find K
Sum1Y <- sum(log(Y[1:i]))
Sum1T <- sum(T[1:i])
Sum1N <- sum(T[1:i] * log(Y[1:i] - T[1:i]*Sum1Y/R))
Sum1D <- sum(T[1:i]^2 - T[1:i]*Sum1T/R)
XK <- Sum1N /Sum1D

##Find log A = C
SumC <- sum((log (Y[1:i]) - XK*T[1:i])/R)
XC <- SumC

#if (XC > 88) do something
XA <- exp(XC)

## Find J

MO <- i
MP <- i+1
AA <- 2 * (1-Y[L])

Sum2Y <- sum(log(YY(Y[MO],AA)))
Sum2T <- sum(T[MO:L]^S[n])
Sum2N <- sum(T[MO:L]^S[n] * log(YY(Y[MO:L],AA))-T[MO:L]^S[n]*Sum2Y)
Sum2D <- sum(T[MO:L]^S[n] *Sum2T/R1 - T[MO:L]^(2*S[n]))
XJ <- Sum2N/Sum2D


```

