---
title: "Optimization of Alumina Kinetics"
author: Sean Taylor and Dennis Taylor
output: html_notebook
---

## Subroutine to evaluate ET(I)

```{r}
library(sintering)
library(dplyr)

data <- alumina %>% filter(Sample == "65")

YY <- function(B,AA) (1-B)/AA
S <- seq(.25,2,by=.25) #Letting the exponent n float
Y <- data$y
T <- data$t
L <- nrow(data) # number of samples

## initialize some results vectors
XK <- c()
XA <- c()
XJ <- c()
XB <- c()
ET <- c()

G <- 1e8

# Various indexes used
MM <- L-2 
N<-1:8
I <- seq(3, MM) # a sample index


## start subroutine
eval <- function(i, n) {
  R<-i # represents the number of samples included in the calculation
  R1 = L-i+1
  
  
  ##Fulfills Line 26 code block
  if (Y[1] -0 < 0.01) start <- 1 else start <- 2
  
  ##Find K
  Sum1Y <- sum(log(Y[start:i]))
  Sum1T <- sum(T[start:i])
  Sum1N <- sum(T[start:i] * log(Y[start:i] - T[start:i]*Sum1Y/R))
  Sum1D <- sum(T[start:i]^2 - T[start:i]*Sum1T/R)
  XK[i] <- Sum1N /Sum1D
  
  ##Find log A = C
  SumC <- sum((log (Y[start:i]) - XK[i]*T[start:i])/R)
  XC <- SumC
  
  if (XC > 88) {
    ET[i] <- 10
    result <-  list(XC=XC, ET=ET[i])
    return(result)
  }
  
  XA[i] <- exp(XC)
  
  ## Find J
  
  MO <- i
  MP <- i+1
  AA <- 2 * (1-Y[L])
  
  Sum2Y <- sum(log(YY(Y[MO],AA)))
  Sum2T <- sum(T[MO:L]^S[n])
  Sum2N <- sum(T[MO:L]^S[n] * log(YY(Y[MO:L],AA))-T[MO:L]^S[n]*Sum2Y)
  Sum2D <- sum(T[MO:L]^S[n] *Sum2T/R1 - T[MO:L]^(2*S[n]))
  XJ[i] <- Sum2N/Sum2D
  
  ## Find Log B = D
  
  SUMD <- sum((XJ[i] * T[MO:L]^S[n] + log(YY(Y[MO:L],AA)))/R1)
  XD <- SUMD
  
  if(XD > 88){
    ET[i] <- 10.0
    result <- list(XD=XD, ET=ET[i])
    return(result)
  } 
  XBB <- exp(XD)
  XB[i] = XBB * AA
  
  ## Evaluate ET(I)
  SUMEIA <- sum((Y[1:i] - XA[i]*exp(XK[i]*T[1:i]))^2)
  
  MN <- i
  M <- i+1
  
  SUMEIB <- sum((Y[MN:L]-1 + XB[i]*exp(-XJ[i]*T[MN:L]^S[n]))^2)
  
  ET[i] <- SUMEIA+SUMEIB
  
  result <- list(XA=XA[i], XK=XK[i], XB=XB[i], XJ=XJ[i], XD=XD, ET=ET[i])
  return(result)
}

## to simulate a for loop, fix i for I and n for N
#i <- 3 ## temporary fix I
#n <- 1 ## temporary fix for N

results <- lapply(setNames(N, S), function (n) {
  results <- lapply(setNames(I,I), eval, n=n)
  return(results)
})

ET <- sapply(results, function (x) sapply(x, "[[", "ET"))
XA <- sapply(results, function (x) sapply(x, "[[", "XA"))
XK <- sapply(results, function (x) sapply(x, "[[", "XK"))
XB <- sapply(results, function (x) sapply(x, "[[", "XB"))
XJ <- sapply(results, function (x) sapply(x, "[[", "XJ"))




```


## Rewrite code principles the R way

```{r}
library(sintering)
library(dplyr)
library(ggplot2)

data <- alumina %>% filter(Sample == "65")

N <- seq(.25,2,by=.25) #Letting the exponent n float
Y <- data$y
T <- data$t


glm(log(y)~t, data=data, family="gaussian")->foo

bar <- lm(log(y)~t, data=data)

plot(data$y, data$x)
abline

p<-ggplot(data)

plot1 <- p + geom_point(aes(x=t, y=y)) +
  scale_y_continuous(trans='log') +
  ##scale_x_continuous(trans='log') +
  geom_line(aes(x=t, y=y), stat="smooth", method="glm") +
  coord_trans(y="exp")

K<-foo$coefficients["t"]
A<-exp(foo$coefficients[1])

pred <- data.frame(t=seq(20, 150, 1))
pred$y <- A*exp(K*pred$t)

plot2<-ggplot() +
  geom_line(data = pred, aes(x=t, y=y)) +
  geom_point(data = data, aes(x=t, y=y)) +
    scale_y_continuous(limits=c(0,2))




foo2 <- glm(log(y)~t, data=data, subset=1:6)
K2<-foo2$coefficients["t"]
A2<-exp(foo2$coefficients[1])

pred2 <- data.frame(t=seq(20, 150, 1))
pred2$y <- A2*exp(K2*pred2$t)

plot3<-ggplot() +
  geom_line(data = pred2, aes(x=t, y=y)) +
  geom_point(data = data, aes(x=t, y=y))+
  scale_y_continuous(limits=c(0,2))





plot1;plot2;plot3


vglm <- function(x, y, index){
  x<-x[1:index]
  
  model <- glm(log(y)~x, family=gaussian)
  return(model)
}

vvglm <- Vectorize(vglm, vectorize.args = "index")

test <- vvglm(x=data$t, y=data$y, index=length(data$t))

test <- lapply(1:nrow(data), function(i){
  model<-glm(log(y)~t, data=data, subset=1:i)
  
  K<-model$coefficients["t"]
  A<-exp(model$coefficients[1])

  pred <- data.frame(t=seq(20, 150, 1))
  pred$y <- A*exp(K*pred$t)

  plot<-ggplot() +
    geom_line(data = pred, aes(x=t, y=y)) +
    geom_point(data = data, aes(x=t, y=y)) +
    scale_y_continuous(limits=c(0,2))
  
  return(plot)

})

test
```


```{r}
library(ggplot2)
#foo<-nls(y ~ 1-(B*exp(-J*(t))), data=data, start=c(B=3, J=0.02),subset=5:14)

data <- alumina %>% filter(Sample == "65")

test2 <- lapply(1:10, function(i){
  model<-nls(y ~ 1-(B*exp(-J*(t))), data=data, start=c(B=3, J=0.02),subset=i:14)
  
  B<-coefficients(model)["B"]
  J<-coefficients(model)["J"]

  pred <- data.frame(t=seq(20, 150, 1))
  pred$y <- 1-(B*exp(-J*pred$t))

  plot<-ggplot() +
    geom_line(data = pred, aes(x=t, y=y)) +
    geom_point(data = data, aes(x=t, y=y)) +
    scale_y_continuous(limits=c(0,2))
  
  return(plot)

})

test2


```

```{r}
library(ggplot2)

test3 <- lapply(1:10, function(i){
  model1 <- glm(log(y)~t, data=data, subset=1:i)
  model2 <- nls(y ~ 1-(B*exp(-J*(t))), data=data, start=c(B=3, J=0.02),subset=i:14)
  
  ET<-sum(resid(model1)^2) + sum(resid(model2)^2)
  
  K<-coef(model1)["t"]
  A<-exp(coef(model1)["(Intercept)"])
  B<-coefficients(model2)["B"]
  J<-coefficients(model2)["J"]

  pred1 <- data.frame(t=seq(20, 150, 1))
  pred1$y <- A*exp(K*pred1$t)
  
  pred2 <- data.frame(t=seq(20, 150, 1))
  pred2$y <- 1-(B*exp(-J*pred2$t))
  

  plot<-ggplot() +
    geom_line(data = pred1, aes(x=t, y=y), color="blue") +
    geom_line(data = pred2, aes(x=t, y=y), color="red") +
    geom_point(data = data, aes(x=t, y=y)) +
    scale_y_continuous(limits=c(0,2))
  
  return(list(ET=ET, plot=plot, K=K, A=A, B=B, J=J))

})

ET <- sapply(test3, function(x) x$ET)
A <- sapply(test3, function(x) x$A)
K <- sapply(test3, function(x) x$K)
B <- sapply(test3, function(x) x$B)
J <- sapply(test3, function(x) x$J)


test3[[which.min(ET)]]$plot

test3[which.min(ET)]

```


## Some ideas from Jason

```{r}
library(inflection)
library(sintering)



load("../Desktop/alumina.Rda")
p <- alumina[alumina$Dope=="Y2O3",]
plot(p$t, p$y)



grid()
bb <- ese(p$t,p$y,0)
bb
pese=bb[,3];pese
abline(v=pese)
cc=bese(p$t,p$y,0)
cc$iplast
abline(v=cc$iplast,col='blue')



foo <- glm(formula = p$y ~ p$t, family=quasibinomial)


range(p$t)

pred <- data.frame(t=seq(20, 150, 1))
xtime <- predict.glm(foo, newdata=pred)




pred <- predict(foo, type="response")
predictions <- gather(pred, key="model", value="y", 2:3)




plot <- ggplot() +
  geom_point(data=p, aes(x=t, y=y))
plot



plot + geom_line(data=data.frame(t=p$t, y=pred), aes(x=t, y=y))


plot(p$t, p$y, more=TRUE)
lines(xtime, ytime, col= "blue", lwd = 2)

spl3 <- smooth.spline(x = p$t, y = p$y, df = 12)
lines(spl3, col = 2)
```


## Using nls to combine both equations
Based on some ideas given to me on stack overflow
https://stackoverflow.com/questions/60728502/fitting-different-parts-of-data-to-different-models-in-r
https://stackoverflow.com/questions/15874214/piecewise-function-fitting-with-nls-in-r


```{r}
library(inflection)
library(sintering)
library(dplyr)
library(tidyr)
library(ggplot2)
library(minpack.lm)

data <- alumina %>% filter(Sample == "65")

inflection <- ese(data$t, data$y, index=0)[3]
alt_inflection <- bese(data$t, data$y, index=0)$iplast

plot <- ggplot() +
  geom_point(data=data, aes(x=t, y=y)) +
  geom_vline(xintercept=inflection, color="blue") +
  geom_vline(xintercept=alt_inflection, color="red", linetype="dashed") 
  
plot


model <- nls(y ~ ifelse(t<inflection,
               A*exp(K*t),
               1-B*exp(J*(t))),
    data=data,
    start=c(A=0.016, K=0.06, B=6, J=-0.04))


model2 <- nlsLM(y ~ ifelse(t<inflection,
               A*exp(K*t),
               1-B*exp(J*(t^n))),
    data=data,
    algorithm = "port",
    control=list(maxiter=100),
    start=c(A=0.016, K=0.06, B=6, J=-0.04, n=1),
    lower=c(-Inf, -Inf, -Inf, -Inf, 0.25),
    upper=c(Inf, Inf, Inf, Inf, 2))


pred <- data.frame(t=seq(20, 150, 1))
pred$model1 <- predict(model, newdata=pred)
pred$model2 <- predict(model2, newdata=pred)

predictions <- gather(pred, key="model", value="y", 2:3)


plot + geom_line(data=predictions, aes(x=t, y=y, group=model, color=model)) 

summary(model)$r.squared
```


## Optimize the inflection point

There is not a seamless transition between the two models. Try to optimze the delta in the y term between the two models

```{r}
library(inflection)
library(sintering)
library(dplyr)
library(tidyr)
library(ggplot2)
library(minpack.lm)

eval <- function (inflection){
  
  model <- nlsLM(y ~ ifelse(t<inflection,
               A*exp(K*t),
               1-B*exp(J*(t^n))),
    data=data,
    algorithm = "port",
    control=list(maxiter=100),
    start=c(A=0.016, K=0.06, B=6, J=-0.04, n=1),
    lower=c(-Inf, -Inf, -Inf, -Inf, 0.25),
    upper=c(Inf, Inf, Inf, Inf, 2))
  
  y1 <- coef(model)['A']*exp(coef(model)['K']*inflection)
  y2 <- 1-(coef(model)['B']*exp(coef(model)['J']*inflection^coef(model)['n']))
  delta <- (y1-y2)^2
  
  r.square <- sum(residuals(model2)^2)
  
  return(list(delta=delta, r.square=r.square, model=model))
  

}


delta <- function(inflection) eval(inflection)$delta
r2 <- function(inflection) eval(inflection)$r.square

optimumInflection <- optimize(f=delta, interval=c(40,80))
optimumR2 <- optimize(f=r2, interval=c(40,80))

resultInflection <- eval(optimumInflection$minimum)
resultInflection.model <- resultInflection$model

resultR2 <- eval(optimumR2$minimum)
resultR2.model <- resultR2$model




pred <- data.frame(t=seq(20, 150, 1))
pred$model1 <- predict(model, newdata=pred)
pred$model2 <- predict(model2, newdata=pred)
pred$model3 <- predict(resultInflection.model, newdata=data.frame(t=seq(20, 150, 1)))
pred$model4 <- predict(resultR2.model, newdata=data.frame(t=seq(20, 150, 1)))


predictions <- gather(pred, key="model", value="y", 2:5)
plot + geom_line(data=predictions, aes(x=t, y=y, group=model, color=model)) 


```





## Ensure both functions include the inflection point

```{r}

eval <- function (inflection){
  
  rhf <- function(t,A,K) ifelse(t<=inflection, A*exp(K*t), 0)
  lhf <- function(t,B,J,n) ifelse(t>=inflection, 1-B*exp(J*(t^n)), 0)
  
  model <- nlsLM(y ~ rhf(t,A,K) + lhf(t,B,J,n),
    data=data,
    algorithm = "port",
    control=list(maxiter=100),
    start=c(A=0.016, K=0.06, B=6, J=-0.04, n=1),
    lower=c(-Inf, -Inf, -Inf, -Inf, 0.25),
    upper=c(Inf, Inf, Inf, Inf, 2))
  
  y1 <- coef(model)['A']*exp(coef(model)['K']*inflection)
  y2 <- 1-(coef(model)['B']*exp(coef(model)['J']*inflection^coef(model)['n']))
  delta <- (y1-y2)^2
  
  r.square <- sum(residuals(model2)^2)
  
  return(list(delta=delta, r.square=r.square, model=model))
  

}



delta <- function(inflection) eval(inflection)$delta
r2 <- function(inflection) eval(inflection)$r.square

optimumInflection <- optimize(f=delta, interval=c(40,80), tol=10)
optimumR2 <- optimize(f=r2, interval=c(40,80),tol=10)

resultInflection <- eval(optimumInflection$minimum)
resultInflection.model2 <- resultInflection$model

resultR2 <- eval(optimumR2$minimum)
resultR2.model2 <- resultR2$model




pred <- data.frame(t=seq(20, 150, 1))
pred$model1 <- predict(model, newdata=pred)
pred$model2 <- predict(model2, newdata=pred)
pred$model3 <- predict(resultInflection.model, newdata=data.frame(t=seq(20, 150, 1)))
pred$model4 <- predict(resultR2.model, newdata=data.frame(t=seq(20, 150, 1)))
pred$model5 <- predict(resultInflection.model2, newdata=data.frame(t=seq(20, 150, 1)))
pred$model6 <- predict(resultR2.model2, newdata=data.frame(t=seq(20, 150, 1)))


predictions <- gather(pred, key="model", value="y", 2:7)
plot + geom_line(data=predictions, aes(x=t, y=y, group=model, color=model)) 


```


```{r}
resultR2
optimumR2
```

```{r}
eval(70)
resultR2
```



## Try fitting a logistic function directly

```{r}

logit_model <- nls(y~L/(1+exp(-k*(t-inflection))),
                   data = data,
                   start=c(L=1, inflection=70, k=0.06))


plot <- ggplot() +
  geom_point(data=data, aes(x=t, y=y))

pred <- data.frame(t=seq(20, 150, 1))
pred$y <- predict(logit_model, newdata=pred)


plot + geom_line(data=pred, aes(x=t, y=y)) +
  geom_vline(xintercept=coef(logit_model)['inflection'], color="blue")


r2<-sum(resid(logit_model)^2)
r2

summary(logit_model)

```



## Direct fit of the pieces

```{r}
library(sintering)

data <- alumina %>% filter(Sample == "70")


for (i in 4:10){
  
  log_model <- nls(y~A*exp(k*t), data=data,start=c(A=1, k=0.06), subset = 1:i)
  invlog_model <- nls(y ~ 1-(B*exp(-J*(t))), data=data, start=c(B=3, J=0.02), subset = i:14)
  logr2 <- sum(resid(log_model)^2)
  invr2 <- sum(resid(invlog_model)^2)
  
  combr2 <- logr2 + invr2
  print(combr2)
}


i <- 5

log_model <- nls(y~A*exp(k*t), data=data,start=c(A=1, k=0.06), subset = 1:i)
invlog_model <- nls(y ~ 1-(B*exp(-J*(t))), data=data, start=c(B=3, J=0.02), subset = i:14)


logpred <- data.frame(t=seq(20, data$t[i], 1))
logpred$y <- predict(log_model, newdata=logpred)

invpred <- data.frame(t=seq(data$t[i], 150, 1))
invpred$y <- predict(invlog_model, newdata=list(t=seq(data$t[i], 150, 1)))


comb_pred <- c(predict(log_model), predict(invlog_model))
comb_pred
 


plot<-ggplot() +
    geom_point(data = data, aes(x=t, y=y)) +
  stat_smooth(aes(x=data$t[c(1:i,i:14)], y=comb_pred), color="green", method="gam") +
  geom_line(data=logpred, aes(x=t, y=y), color="blue", linetype="dotted") +
  geom_line(data=invpred, aes(x=t, y=y), color="red", linetype="dotted") +
  geom_point(aes(x=data$t[1:i], y=predict(log_model)), color="blue") +
  geom_point(aes(x=data$t[i:14], y=predict(invlog_model)), color="red") 
plot


```

```{r}
# Helper functions

logmodelfit <- function(i,data) {
    log_lm <- lm(log(y) ~ t, data)
    st <- list(A = exp(coef(log_lm)[1]), k = coef(log_lm)[2])

    log_model <- nls(y~A*exp(k*t), data=data,start=st, subset = 1:i)

}

invlogmodelfit <- function(i,data) {
    invlog_model <- nls(y ~ 1-(B*exp(-J*(t))), data=data, start=c(B=3, J=0.02), subset = i:14)
}

optimizelogfit <- function(timepoints, data){
    models<-lapply(setNames(timepoints, timepoints), function(t,data) {

        log_model <- logmodelfit(t, data)
        invlog_model <- invlogmodelfit(t, data)

        logr2 <- sum(resid(log_model)^2)
        invr2 <- sum(resid(invlog_model)^2)
        r2 <- logr2 + invr2

        result <- list(log_model=log_model, invlog_model=invlog_model, r2=r2)

    },
    data=data)
}


validInflIdx <- 4:(length(data$Sample)-3)


full_model <- optimizelogfit(validInflIdx, data)

index <- as.character(validInflIdx[1])
index

full_model[[index]]

full_model[[1]]

r2 <- sapply(full_model, "[[", "r2")

names(which.min(r2))

validInflIdx[which.min(r2)]

results <- ({
  paramA<- sapply(full_model, function(x) coef(x$log_model)["A"])
  paramK<- sapply(full_model, function(x) coef(x$log_model)["k"])
  paramB<- sapply(full_model, function(x) coef(x$invlog_model)["B"])
  paramJ<- sapply(full_model, function(x) coef(x$invlog_model)["J"])
  paramR2<- sapply(full_model, "[[", "r2")
  
  rbind(paramA, paramK, paramB, paramJ, paramR2)
})
results

results <- lapply(full_model, function(x){
  A <- coef(x$log_model)["A"]
  K<- coef(x$log_model)["k"]
  B<- coef(x$invlog_model)["B"]
  J<- coef(x$invlog_model)["J"]
  R2<- x$r2
  
  list(A=A, K=K, B=B, J=J, R2=R2)
})

results

```

